const container = document.getElementById("array-container");
const statusPanel = document.getElementById("status-text");

// Sound effects
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

/**
 * Generates a sound tone using the Web Audio API.
 * @param {number} freq - The frequency of the tone in Hz.
 * @param {string} type - The type of oscillator (e.g., "sine", "square").
 * @param {number} duration - The duration of the tone in seconds.
 */
function playTone(freq, type = "sine", duration = 0.1) {
  if (audioCtx.state === "suspended") audioCtx.resume();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(
    0.00001,
    audioCtx.currentTime + duration
  );
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

/**
 * Pauses execution for a specified duration.
 * @param {number} ms - The number of milliseconds to sleep.
 * @returns {Promise} A promise that resolves after the specified time.
 */
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Renders the array elements as bars in the DOM.
 * @param {number[]} arr - The array of numbers to visualize.
 */
function renderArray(arr) {
  container.innerHTML = "";
  arr.forEach((value) => {
    const bar = document.createElement("div");
    bar.classList.add("bar");
    bar.style.height = `${value * 3}px`;
    bar.setAttribute("data-value", value);

    const label = document.createElement("span");
    label.innerText = value;
    bar.appendChild(label);

    container.appendChild(bar);
  });
}

/**
 * Iterates through the search steps and animates the visualization.
 * @param {Object[]} steps - The list of steps generated by the search algorithm.
 */
async function playAnimation(steps) {
  const bars = document.getElementsByClassName("bar");
  let stepCounter = 0;

  for (let i = 0; i < steps.length; i++) {
    const step = steps[i];

    // Update status
    if (step.status) {
      statusPanel.innerText = step.status;
    }

    // Handle different step types
    if (step.type === "sort") {
      // Special step for binary search start
      renderArray(step.sortedArray);
      await sleep(1000);
      continue;
    }

    // Reset previous highlights (simple approach: remove active from all)
    // For binary search, we might want to keep 'visited' grayed out, but let's keep it simple first
    // or try to follow the logic.
    // The Java logic sends "check" or "found".

    // If it's a check, we highlight the current index
    if (step.index !== -1 && step.index < bars.length) {
      const bar = bars[step.index];

      // Increment step counter for visual feedback
      if (step.type === "check" || step.type === "found") {
        stepCounter++;
        const badge = document.createElement("div");
        badge.classList.add("step-badge");
        badge.innerText = stepCounter;
        bar.appendChild(badge);

        // Trigger animation
        requestAnimationFrame(() => {
          badge.classList.add("show");
        });
      }

      // Visual feedback based on type
      if (step.type === "found") {
        bar.classList.remove("active");
        bar.classList.add("found");
        playTone(880, "square", 0.3);
        // Stop here? The loop will finish naturally as steps end.
      } else if (step.type === "check") {
        bar.classList.add("active");
        playTone(440 + step.index * 10);
        await sleep(500);
        bar.classList.remove("active");
        bar.classList.add("visited"); // Mark as visited

        // For binary search, we can visualize the bounds if provided
        if (step.left !== undefined && step.right !== undefined) {
          // Gray out everything outside left/right?
          for (let j = 0; j < bars.length; j++) {
            if (j < step.left || j > step.right) {
              bars[j].style.opacity = "0.3";
            } else {
              bars[j].style.opacity = "1";
            }
          }
        }
      } else if (step.type === "not_found") {
        playTone(200, "sawtooth", 0.5);
      }
    }

    await sleep(100); // Small pause between steps if not handled by 'check' sleep
  }
}

// Initialize
if (typeof initialArray !== "undefined") {
  renderArray(initialArray);
}

if (typeof searchSteps !== "undefined" && searchSteps !== null) {
  // Small delay to let the user see the page load before animation starts
  setTimeout(() => {
    playAnimation(searchSteps);
  }, 500);
}
